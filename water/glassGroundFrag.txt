#version 330 core
out vec4 FragColor;
in vec3 WorldPos;
in vec2 textcoor;
uniform vec3 lightPosition;
uniform vec3 lightColor;
uniform vec3 camPos;

uniform vec3 spherePos;
uniform float sphereRadius;
uniform sampler2D texture0;
uniform sampler2D albedoMap;

uniform struct render_spheres {
  vec3 sphere_pos[100];
  float sphere_Radius[100];
  int size;
} spheres;

float PI = 3.1415926;

vec3 reflected;

vec4 hit(vec3 s_pos, float radius, vec3 viewDir, vec3 N){ //s_pos is the position of sphere
	if(camPos.y < WorldPos.y) return vec4(0);
	if(s_pos.y < WorldPos.y ) return vec4(0);
	float t = -1.0f;
	vec4 result = vec4(0);
	vec3 sphere_curpoint = WorldPos - s_pos;
	float a = dot(reflected, reflected);
	float b = 2.0f * dot(sphere_curpoint, reflected);
	float c = dot(sphere_curpoint, sphere_curpoint) - radius * radius;
	float discriminant = b*b - 4*a*c;
	if(discriminant >= 0) {
		t = (-b - sqrt(discriminant)) / (2.0f * a);
		if(t < 0) t = (-b + sqrt(discriminant)) / (2.0f * a);
		if(t < 0) return vec4(0);
		vec3 hitPoint = WorldPos + t * reflected;
		vec3 d = normalize(s_pos - hitPoint);
		vec2 uv = vec2(0.5 + atan(d.z, d.x) / (2 * PI), 0.5 - asin(d.y) / PI);
		result = texture(albedoMap, uv);
	}
	return result;
}

float calShadow(vec3 s_pos, float radius, vec3 lightDir){
	float t = -1.0f;
	float result = 0.0f;
	vec3 sphere_curpoint = WorldPos - s_pos;
	float a = dot(lightDir, lightDir);
	float b = 2.0f * dot(sphere_curpoint, lightDir);
	float c = dot(sphere_curpoint, sphere_curpoint) - radius * radius;
	float discriminant = b*b - 4*a*c;
	if(discriminant >= 0) {
		t = (-b - sqrt(discriminant)) / (2.0f * a);
		if(t < 0) t = (-b + sqrt(discriminant)) / (2.0f * a);
		if(t < 0) return 0.0f;
		result = 1.0f;
	}
	return result;
}

void main()
{		
	vec3 Normal = vec3(0,1,0);
    vec3 ViewVec = normalize(camPos - WorldPos);
    vec3 LightVec = normalize(lightPosition);
    vec3 halfVec = normalize(ViewVec + LightVec);
	reflected = reflect(-ViewVec, Normal);

	vec4 color = texture(texture0, textcoor);
	vec3 onlyColor = vec3(color);
	float spec = pow(max(dot(reflect(-ViewVec,Normal),LightVec), 0.0), 5);
	vec3 specular = spec * lightColor;

	float diff = max(dot(LightVec, Normal), 0.0);
    vec3 diffuse = diff * lightColor;

	/*
	float inShadow = calShadow(spherePos, sphereRadius, LightVec);
	if(inShadow > 0) onlyColor = vec3(color) * 0.2f;
	onlyColor = onlyColor / (onlyColor + vec3(1.0));
    onlyColor = pow(onlyColor, vec3(1.0/2.2)); 
	FragColor = vec4(onlyColor, color.w);
	vec4 result = hit(spherePos, sphereRadius, ViewVec, Normal);
	if(length(result) > 0) FragColor = mix(result, FragColor, 0.5);
	*/

	float weDontHaveShadow = 1.0f;
	for(int i = 0; i < spheres.size; ++i) {
		float inShadow = calShadow(spheres.sphere_pos[i], spheres.sphere_Radius[i], LightVec);
		if(inShadow > 0) {
			onlyColor = onlyColor * 0.2f;
			weDontHaveShadow = 0;
		}
	}
	onlyColor = onlyColor + weDontHaveShadow * (diffuse + specular) * vec3(color);
	onlyColor = onlyColor / (onlyColor + vec3(1.0));
    onlyColor = pow(onlyColor, vec3(1.0/2.2));
	FragColor = vec4(onlyColor, color.w);

	for(int i = 0; i < spheres.size; ++i) {
		vec4 result = hit(spheres.sphere_pos[i], spheres.sphere_Radius[i], ViewVec, Normal);
		if(length(result) > 0) FragColor = mix(result, FragColor, 0.5);
	}
	

	
	//FragColor.w = color.w;
}