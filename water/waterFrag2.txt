#version 330 core
out vec4 FragColor;
in FRAG_IN {
 vec3 wNormal;
  vec3 WorldP;
} geo_out;

uniform sampler2D normalMap;

// material parameters
uniform vec3 albedo;
//vec3 albedo = vec3(0, 0.412, 0.58);
uniform float metallic;
uniform float roughness;
uniform float ao;

// lights
uniform vec3 lightPosition;
uniform vec3 lightColor;
uniform vec3 camPos;

const float PI = 3.14159265359;
vec3 Normal;
vec3 WorldPos;
vec3 ViewVec;
vec3 LightVec;
vec3 halfVec;
float threshold = 0.000000001;

float H(vec3 a, vec3 b){
	float dotResult = dot(a,b);
	if(dotResult < 0) return 0;
	else return dotResult;
    //return step(0, dot(a,b));
}

float erfc(float x) {
	return 2.0 * exp(-x * x) / (2.319 * x + sqrt(4.0 + 1.52 * x * x));
}


float lambda(float vr){
    return (exp(-vr*vr) - vr * sqrt(PI) * erfc(vr)) / (2*vr*sqrt(PI));
}


void main()
{		
	WorldPos = geo_out.WorldP;
    Normal = geo_out.wNormal;
    ViewVec = normalize(camPos - WorldPos);
    LightVec = normalize(vec3(0.0f, 0.5f, -0.8f));
    halfVec = normalize(ViewVec + LightVec);
    float thetaL = acos(LightVec.y);
    float phiL = atan(LightVec.z, LightVec.x);
    float thetaV = acos(ViewVec.y);
    float phiV = atan(ViewVec.z, ViewVec.x);
    float slopeX = - Normal.x / Normal.y;
    float slopeY = - Normal.z / Normal.y;
    float U = 12.5f; //wind speed
    float sigmaX = sqrt(0.00316 * U + 0.004);
    float sigmaY = sqrt(0.003 + 0.00192*U + 0.004);
    float slopeGD = pow(1.0f /(2*PI*sigmaX*sigmaY), -0.5f*((slopeX*slopeX) / (sigmaX*sigmaX) + (slopeY*slopeY) / (sigmaY*sigmaY))); //slope gaussian distribution 
    
    //calculate visibility probability distribution
    float q_vn_nom = slopeGD * max(dot(ViewVec, Normal), 0) * H(LightVec, Normal);
    float sigma_phi_V = sqrt(sigmaX*sigmaX*cos(phiV)*cos(phiV) + sigmaY*sigmaY*sin(phiV)*sin(phiV));
    float vr = (1.0f / tan(thetaV)) / max(sqrt(2.0f) * sigma_phi_V, 0.001);
    float lambdaV = lambda(vr);
    float sigma_phi_L = sqrt(sigmaX*sigmaX*cos(phiL)*cos(phiL) + sigmaY*sigmaY*sin(phiL)*sin(phiL));
    float vs = (1.0f / tan(thetaL)) / max(sqrt(2.0f) * sigma_phi_L, 0.001);
    float lambdaL = lambda(vs);
    float q_vn_denom = max((1 + lambdaV + lambdaL) * Normal.y * cos(thetaV), 0.001);
    float q_vn = min(q_vn_nom / q_vn_denom, 1.0f);

    //calculate BRDF
    float fresnel = 0.02 + 0.98 * pow(1.0 - dot(ViewVec, halfVec), 5.0);
    float brdf = (q_vn * fresnel) / max((4 * pow(halfVec.y, 3) * cos(thetaL) * dot(ViewVec, halfVec)), 0.01);

    //now actually calculate color
    vec3 radiance = lightColor;
    vec3 ambient = 0.8 * vec3(0, 0.467, 0.745);
    vec3 color = ambient + radiance * brdf;

    // HDR tonemapping
    color = color / (color + vec3(1.0));
    // gamma correct
    color = pow(color, vec3(1.0/2.2)); 

    FragColor = vec4(color, 1.0);

	//float tmp = max(dot(ViewVec, Normal), 0);
	//FragColor = vec4(vec3(1) * tmp, 1);
}