#version 330 core
out vec4 FragColor;
in FRAG_IN {
  vec3 wNormal;
  vec3 WorldP;
  vec4 fragLightSpacePos;
} geo_out;

uniform sampler2D normalMap;
uniform sampler2D shadowMap;

// material parameters
uniform vec3 albedo;
//vec3 albedo = vec3(0, 0.412, 0.58);
uniform float metallic;
uniform float roughness;
uniform float ao;

// lights
uniform vec3 lightPosition;
uniform vec3 lightColor;
uniform vec3 camPos;

const float PI = 3.14159265359;
vec3 Normal;
vec3 WorldPos;
vec3 ViewVec;
vec3 LightVec;
vec3 halfVec;
vec4 fragLightSpacePos;
float threshold = 0.000000001;

vec3 addNoise(vec3 N){
	float div = 10.0f;
	float noisex = fract(cos(dot(N ,vec3(24.216547, 56.4578, 98.2465))) * 73569.4124) / div;
	float noisey = fract(cos(dot(N ,vec3(24.216547, 56.4578, 98.2465))) * 73569.4124) / div;
	float noisez = fract(cos(dot(N ,vec3(24.216547, 56.4578, 98.2465))) * 73569.4124) / div;
    return normalize(N + vec3(noisex, noisey, noisez));
}

float H(vec3 a, vec3 b){
	float dotResult = dot(a,b);
	if(dotResult < 0) return 0;
	else return dotResult;
    //return step(0, dot(a,b));
}

float erfc(float x) {
	return 2.0 * exp(-x * x) / (2.319 * x + sqrt(4.0 + 1.52 * x * x));
}


float lambda(float vr){
    return (exp(-vr*vr) - vr * sqrt(PI) * erfc(vr)) / (2*vr*sqrt(PI));
}

vec3 getSkyColor(vec3 e) {
    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;
    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;
}

float calShadow(){
    vec3 projCoords = fragLightSpacePos.xyz / fragLightSpacePos.w;
    projCoords = projCoords * 0.5 + 0.5;
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    float currentDepth = projCoords.z;
    float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;
    return shadow;
}

void main()
{		
	WorldPos = geo_out.WorldP;
    Normal = geo_out.wNormal;
    ViewVec = normalize(camPos - WorldPos);
    LightVec = normalize(lightPosition);
    halfVec = normalize(ViewVec + LightVec);
	fragLightSpacePos = geo_out.fragLightSpacePos;
    float thetaL = acos(LightVec.y);
    float phiL = atan(LightVec.z, LightVec.x);
    float thetaV = acos(ViewVec.y);
    float phiV = atan(ViewVec.z, ViewVec.x);
    float slopeX = - Normal.x / Normal.y;
    float slopeY = - Normal.z / Normal.y;
    float U = 12.5f; //wind speed
    float sigmaX = sqrt(0.00316 * U + 0.004);
    float sigmaY = sqrt(0.003 + 0.00192*U + 0.004);
    float slopeGD = pow(1.0f /(2*PI*sigmaX*sigmaY), -0.5f*((slopeX*slopeX) / (sigmaX*sigmaX) + (slopeY*slopeY) / (sigmaY*sigmaY))); //slope gaussian distribution 
    
    //calculate visibility probability distribution
    float q_vn_nom = slopeGD * max(dot(ViewVec, Normal), 0) * H(LightVec, Normal);
    float sigma_phi_V = sqrt(sigmaX*sigmaX*cos(phiV)*cos(phiV) + sigmaY*sigmaY*sin(phiV)*sin(phiV));
    float vr = (1.0f / tan(thetaV)) / max(sqrt(2.0f) * sigma_phi_V, 0.001);
    float lambdaV = lambda(vr);
    float sigma_phi_L = sqrt(sigmaX*sigmaX*cos(phiL)*cos(phiL) + sigmaY*sigmaY*sin(phiL)*sin(phiL));
    float vs = (1.0f / tan(thetaL)) / max(sqrt(2.0f) * sigma_phi_L, 0.001);
    float lambdaL = lambda(vs);
    float q_vn_denom = max((1 + lambdaV + lambdaL) * Normal.y * cos(thetaV), 0.001);
    float q_vn = min(q_vn_nom / q_vn_denom, 1.0f);

    //calculate BRDF
    float fresnel1 = 0.02 + 0.98 * pow(1.0 - dot(ViewVec, halfVec), 5.0);
	float fresnel2 = clamp(1.0 - dot(Normal,ViewVec), 0.0, 1.0) - max(dot(LightVec, ViewVec), 0) * 0.5;
    fresnel2 = pow(fresnel2,3.0) * 0.5;
	float fresnel = mix(fresnel1, fresnel2, 0.4);
    float brdf = (q_vn * fresnel) / max((4 * pow(halfVec.y, 3) * cos(thetaL) * dot(ViewVec, halfVec)), 0.01);

	
    float specular = pow(max(dot(reflect(-ViewVec,Normal),LightVec),0.0),60) * (60 + 8.0) / (PI * 8.0);

	vec3 dist =  WorldPos - camPos;
	float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);

    //now actually calculate color
    vec3 radiance = lightColor;
    vec3 ambient = 0.8 * vec3(0, 0.467, 0.745); 
	vec3 reflected = getSkyColor(reflect(-ViewVec,Normal));    
	float diffuse = pow(dot(Normal,LightVec) * 0.4 + 0.6, 80);
    vec3 refracted = vec3(0.0,0.09,0.18) + diffuse * vec3(0.8,0.9,0.6)*0.6 * 0.12; 
	vec3 tmp = mix(reflected, refracted, fresnel);
	ambient = mix(ambient, tmp, fresnel);
    vec3 color = ambient + radiance * brdf + radiance * specular;
	color += vec3(0.8,0.9,0.6)*0.6 * (WorldPos.y - (-1.0f)) * 0.18 * atten;

    // HDR tonemapping
    color = color / (color + vec3(1.0));
    // gamma correct
    color = pow(color, vec3(1.0/2.2)); 

    FragColor = vec4(color, 1.0);

	//if(calShadow() > 0) FragColor = vec4(1, 0, 0, 1);

	//float tmp = max(dot(ViewVec, Normal), 0);
	//FragColor = vec4(vec3(1) * tmp, 1);
}